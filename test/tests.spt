/**
* Unit tests for the SLL language.
*/
module tests

language SLL

setup Common [[
     program example
]]

test Eval F-function [[
      succ(x) = S(x)

      main = succ(Z())
]] build run-main to "S(Z())"

test Eval G-function [[
     add(Z(), y) = y
     add(S(x), y) = S(add(x,y))

     main = add(S(S(Z())), S(Z()))
]] build run-main to "S(S(S(Z())))"

test Lazy evaluation [[
    head(Cons(x, xs)) = x
    tail(Cons(x, xs)) = xs

    // infinite list of Z()
    zeros() = Cons(Z(), zeros())

    main = head(zeros())
]] build run-main to "Z()"

test Equal modulo renaming [[
        add(Z(), y) = y
        add(S(x), y) = S(add(x,y))

        f(x) = add(S(x), Z())
        g(y) = add(S(y), Z())
]] run test-eq

test Not equal modulo renaming [[
        add(Z(), y) = y
        add(S(x), y) = S(add(x,y))

        f(x) = add(S(S(x)), Z())
        g(y) = add(S(y), Z())
]] run test-not-eq

test Generation 1[[
    plusOne(x) = S(x)

    main = plusOne(plusOne(x))

]] run test-gen to []

test Generation 2[[
    add(Z(), y) = y
    add(S(x), y) = S(add(x,y))

    main = add(x, Z())

]] run test-gen to []
