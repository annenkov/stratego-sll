module generate

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/SLL
  lib/editor-common.generated
  lib/analysis-library.generated
  lib/analysis-library-internal.generated
  lib/index-library.generated
  names
  

rules
// Using dynamic rules
  create-env:
  	t -> t
  	with
  		<topdown(try(record-func-defs))> t
  		
  record-func-defs:
  	FDef(name, vars, body) -> FDef(name, vars, body)
  	with
	  	rules(
	  			func-def : name -> body
	  		)
	  		
// end of dynamic rules section

  // Getting definition by explicit traversals 
  get-f-func-body(|prog):
  	FCall(name, args*) -> (body, <build-env> (vars*, args*))
  	where
  		<debug> (name, args*, prog);
  		<collect-one(?FDef(name, vars*, body))> prog
  
  get-g-func-body(|prog):
  	FCall(name,[Ctor(ctor-name, ctor-args*)]) -> 
  	    (body, <build-env>(ctor-vars*, ctor-args*))
  	where  		  	
  		<collect-one(?GDef(name, Pat(ctor-name, ctor-vars*), body))> prog
  	
  get-g-func-body(|prog):
  	FCall(name,[Ctor(ctor-name, ctor-args*), args* ]) -> 
  	    (body, <conc> (<build-env>(ctor-vars*, ctor-args*), <build-env>(vars*, args*)))  	
  	where
  		<collect-one(?GDef(name, Pat(ctor-name, ctor-vars*), vars*, body))> prog
  
  get-func-body(|prog) = get-g-func-body(|prog) <+ get-f-func-body(|prog)
   	  		
  rewrite-func(|prog):
  	func@FCall(name, args*) -> f
  	where
  		<debug(!"Function: ")> func;
  		(body, env) := <get-func-body(|prog)> func;
  		<debug(!"Resolved body: ")> body;
  		<debug(!"Env: ")> env;  		
  		f := <substitute(|env)> body
  	  	
  rewrite-step(|prog) = rewrite-func(|prog) <+ FCall(id, [rewrite-step(|prog)|id])  	  		
  
  build-env:
  	(vars*@[v|_], args*) -> env
  	with
  		env := <zip> (<map(?DVar(<id>))>vars*, args*)
  		
  build-env:
  	(vars*@[v|_], [Ctor(n, []), args*]) -> env
  	with
  		<debug> (vars*, args*);
  		env := <zip> (<map(?DVar(<id>))>vars*, args*)		
  		
  build-env:
  	(_, []) -> []

  substitute(|env) : ctor@Ctor(n, []) -> ctor
  		
  substitute(|env) : Ctor(n, args*) -> t
  	with
  		<debug(!"Recursing on Ctor: ")> args*;
  		t := Ctor(n, <map(substitute(|env))> args*)
  		
  substitute(|env) : FCall(n, args*) -> t
  	with  		
  		<debug(!"Recursing on FCall: ")> args*;
  		t := FCall(n, <map(substitute(|env))> args*) 		
    	
  substitute(|env) : Var(a) -> arg
  		where 
  			arg := <lookup>(a, env);
  			<debug(!$[Substitite: [a]--->])> arg 
  		
  substitute(|env) : e@Var(a) -> e
  		where <not(lookup)> (a, env);
  		<debug(!"Not changing: ")> a
  		
  eval(r|prog) = rec e(try(r(|prog) ; e); Ctor(id, map(e)))
  
  rewrite-main-def-alt(|prog):
  	Expr(body) -> t
  	with
  		t := <reduce(rewrite-func(|prog))> body  		
  
  rewrite-main-def(|prog):
  	Expr(body) -> t
  	with
  		t := <eval(rewrite-step|prog)> body
  		
  lookup-0:
  	func -> f
  	with
  		f := <index-lookup> func
  		
  definition-of:
    MainDef(Expr(body)) -> t
    with    	
    	<debug> <index-uri>;
    	t := <nam-get-uses> body