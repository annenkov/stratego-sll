module generate

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/SLL
  lib/editor-common.generated
  lib/analysis-library.generated
  lib/analysis-library-internal.generated
  lib/index-library.generated
  names
  

rules

  // Getting definition by explicit traversals 
  get-f-func-body(|prog):
  	FCall(name, args*) -> (body, <build-env> (vars*, args*))
  	where
  		<debug> (name, args*, prog);
  		<collect-one(?FDef(name, vars*, body))> prog
  
  get-g-func-body(|prog):
  	FCall(name,[Ctor(ctor-name, ctor-args*)]) -> 
  	    (body, <build-env>(ctor-vars*, ctor-args*))
  	where  		  	
  		<collect-one(?GDef(name, Pat(ctor-name, ctor-vars*), body))> prog
  	
  get-g-func-body(|prog):
  	FCall(name,[Ctor(ctor-name, ctor-args*), args* ]) -> 
  	    (body, <conc> (<build-env>(ctor-vars*, ctor-args*), <build-env>(vars*, args*)))  	
  	where
  		<collect-one(?GDef(name, Pat(ctor-name, ctor-vars*), vars*, body))> prog
  
  get-func-body(|prog) = get-g-func-body(|prog) <+ get-f-func-body(|prog)

  // Unfolding and substitution  	  		
  rewrite-func(|prog):
  	func@FCall(name, args*) -> f
  	where
  		<debug(!"Function: ")> func;
  		(body, env) := <get-func-body(|prog)> func;
  		<debug(!"Resolved body: ")> body;
  		<debug(!"Env: ")> env;  		
  		f := <substitute(|env)> body
  	  	
  rewrite-step(|prog) = rewrite-func(|prog) <+ FCall(id, [rewrite-step(|prog)|id])  	  		
  
  build-env:
  	(vars*@[v|_], args*) -> env
  	with
  		env := <zip> (<map(?DVar(<id>))>vars*, args*)
  		
  build-env:
  	(vars*@[v|_], [Ctor(n, []), args*]) -> env
  	with
  		<debug> (vars*, args*);
  		env := <zip> (<map(?DVar(<id>))>vars*, args*)		
  		
  build-env:
  	(_, []) -> []

  substitute(|env) : ctor@Ctor(n, []) -> ctor
  		
  substitute(|env) : Ctor(n, args*) -> t
  	with
  		<debug(!"Recursing on Ctor: ")> args*;
  		t := Ctor(n, <map(substitute(|env))> args*)
  		
  substitute(|env) : FCall(n, args*) -> t
  	with  		
  		<debug(!"Recursing on FCall: ")> args*;
  		t := FCall(n, <map(substitute(|env))> args*) 		
    	
  substitute(|env) : Var(a) -> arg
  		where 
  			arg := <lookup>(a, env);
  			<debug(!$[Substitite: [a]--->])> arg 
  		
  substitute(|env) : e@Var(a) -> e
  		where <not(lookup)> (a, env);
  		<debug(!"Not changing: ")> a
  
 
  eval1(r|prog) = rec e(try(r(|prog) ; e); (id, Ctor(id, map(try(rewrite-func(|prog))))); e)
   
  // alternative rewrite-step and eval
  
  rewrite-step-alt(|prog) = rewrite-func(|prog) <+ FCall(id, [rewrite-step(|prog)|id]) <+ Ctor(id, map(rewrite-step-alt(|prog)))
  
  is-complete = not(collect-one(?FCall(_,_)))
  
  eval3(r) = rec e(r; (is-complete <+ e))
  
  ana(unspool, finished): t -> [a|<if finished then ![] else ana(unspool, finished) end> y]
  with
  	(a,y) := <unspool> t
  
  to-tuple: t -> (t,t)
  
  eval-trace-ana(r) = ana((r; to-tuple), is-complete)
  	 
  
  rewrite-main-def-alt(|prog):
  	Expr(body) -> t
  	with
  		t := <reduce(rewrite-func(|prog))> body  		
  
  rewrite-trace(|prog, trace): (trace, e) -> (new-trace, result)
  	where
  		<debug> (trace, e);
  		result := <rewrite-step(|prog)> e;
  		<debug> result;
  		new-trace := <conc> (trace, [result])
  
  rewrite-main-def(|prog):
  	Expr(body) -> t
  	with
  		t := <eval3(rewrite-step-alt(|prog))> body
  		
  rewrite-trace-main-def(|prog):
  	Expr(body) -> [body|t]
  	with
  		t := <eval-trace-ana(rewrite-step-alt(|prog))> body  		
  		   	
  // Using dynamic rules - not finished yet
  create-env:
  	t -> t
  	with
  		<topdown(try(record-func-defs))> t
  		
  record-func-defs:
  	FDef(name, vars, body) -> FDef(name, vars, body)
  	with
	  	rules(
	  			func-def : name -> body
	  		)
	  		
// end of dynamic rules section    	