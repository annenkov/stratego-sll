module conftree

imports
    libstratego-lib
    libstratego-aterm
    lib/editor-common.generated
    include/SLL
    interpreter
    testhelpers

signature
    sorts
        Step Tree Either
    constructors
        Transient   : Expr -> Step
        Fold        : Expr * [String] -> Step
        Stop        : Step
        Variants    : [Pattern] * [Expr] -> Step
        Decompose   : [Expr] -> Step

        Node        : Expr * [Expr] -> Tree
        Leaf        : Expr -> Tree

        Left        : Expr -> Either
        Right       : Expr -> Either
rules

    prettify-tree(pp) = topdown(try(pp))

    build-conf-tree(|prog) = conf-tree(rewrite-step-alt(|prog)|prog)
    conf-tree(r|prog) = !(<id>, []); ana-tree(drive(r|prog))

    drive(r|prog): (t@Ctor(_,_), acc) -> Left(t)
    where
        <is-complete> t

    drive(r|prog): (t@Ctor(_, args*@[_|_]), acc) -> Decompose((t, <map(!(<id>, [t|acc]))> args*))
    where
        <not(is-complete)> t;
        <debug(!"Decompose: ")> t

    drive(r|prog): (t@FCall(_, _), acc) -> Transient((t, (new-t, [t|acc])))
     where
        <debug(!"Transient?")> t;
        new-t := <r> t;
        <debug(!"Transient: ")> t


    drive(r|prog): (t@FCall(_, _), acc) -> Variants(pats*, (t, <map(!(<r>, [t|acc]))> funcalls*))
    where
        <debug(!"Variants?")> t;
        (pats*, funcalls*) := <variants-r(|prog)> t;
        <debug(!"Variants: ")> funcalls*;
        <not(foldable(|acc))> t

    drive(r|prog): (t@FCall(_, _), acc) -> Fold(folded-to, renamings)
    where
        (folded-to, renamings) := <foldable(|acc)> t;
        <debug(!"Foldable: ")> (t, folded-to)

    foldable(|acc): t -> (t', renamings)
    where
        <debug> t;
        t' := <getfirst(eq-mod-renaming(|t))> acc;
        renamings := <zip> (<collect-all(?Var(<id>))> t', <collect-all(?Var(_))> t)

    ana-tree(unspool): a ->
        <switch unspool
            case ?Left(t): !Leaf(t)
            case ?Fold(t, renamings): !Leaf(Fold(t, renamings))
            case ?Decompose((t, y)): !Node(t, Decompose(<map(ana-tree(unspool))> y))
            case ?Variants(pats*, (t, y)): !Node(t, Variants(pats*, <map(ana-tree(unspool))> y))
            case ?Transient((t, y)): !Node(t, Transient(<ana-tree(unspool)> y))
        end> a
        with
            <debug> a

    variants-r(|prog) = variants(|prog) <+ (?FCall(name, [a|args*]); <variants-r(|prog)> a; inject(|name, args*))

    inject(|name, args*) = (id, map(!FCall(name, [<id>|args*])))

    variants(|prog): fcall@FCall(f-name, [Var(_)|_]) -> (pats*, fcalls*)
    where
        g-defs* := <collect-all(?GDef(f-name, _, _, _)); ?[_|_]> prog;
        res := <map(variants-step(|fcall))> g-defs*;
        pats* := <map(?(<id>, _))> res;
        fcalls* := <map(?(_, <id>))> res;
        <debug> res

    variants-step(|f-call): GDef(name, pat, args*, body) -> (new-pat, res)
    where
        <?FCall(f-name, [Var(var-name)|_])> f-call;
        new-pat := <pat-with-new-vars> pat;
        res := <substitute(|[(var-name, <pat2ctor> new-pat)])> f-call

    pat-with-new-vars: Pat(n, a*) -> Pat(n, new-vars*)
    with
        new-vars* := <topdown(try(\DVar(_) -> DVar(<new>)\))> a*


    pat2ctor: Pat(name, args*) -> Ctor(name, <topdown(try(\DVar(x) -> Var(x)\))> args*)
    //pat2ctor: Pat(name, args*) -> Ctor(name, <topdown(try(\DVar(x) -> Var(<new>)\))> args*)

    eq-mod-renaming(|t1): t2 -> t2
    where
        <debug(!"Comparing")> (t1, t2);
    	<equal> (<erase-names> t1, <erase-names> t2)

    erase-names = topdown(try(?Var(_); !Var("_")))

    test-eq: t -> <get-defs(?FDef("g", _, <id>) <+ ?FDef("f", _, <id>)); ?[t1, t2]; <eq-mod-renaming(|t1)> t2> t
    test-not-eq: t -> <not(test-eq)> t
