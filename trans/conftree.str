module conftree

imports
    libstratego-lib
    libstratego-aterm
    lib/editor-common.generated
    include/SLL
    interpreter
    utils

signature
    sorts
        Step Tree Either
    constructors
        Transient   : Expr -> Step
        Fold        : Expr * [String] -> Step
        Stop        : Expr -> Step
        Variants    : [Pattern] * [Expr] -> Step
        Decompose   : [Expr] -> Step

        Node        : Expr * [Expr] -> Tree
        Leaf        : Expr -> Tree

        Left        : Expr -> Either
        Right       : Expr -> Either
rules

    prettify-tree(pp) = topdown(try(pp))

    build-conf-tree(|prog): t -> <conf-tree(rewrite-step-alt(|prog)|prog)>
    with
        init-trace

    conf-tree(r|prog) = ana-tree(drive(r|prog))

    drive(r|prog): t@Ctor(_,_) -> Stop(t)
    where
        <is-complete> t

    drive(r|prog): t@Var(_) -> Stop(t)

    drive(r|prog): t@Ctor(_, args*@[_|_]) -> Decompose((t, args*))
    where
        <not(is-complete)> t;
        <debug(!"Decompose: ")> t

    drive(r|prog): t@FCall(_, _) -> Transient((t, new-t))
     where
        new-t := <r> t;
        <debug(!"Transient: ")> (<pp-sll-string> t, <pp-sll-string> new-t);
     update-trace(|t)

    drive(r|prog): t@FCall(_, _) -> Variants(pats*, (t, <map(r)> funcalls*))
    where
        (pats*, funcalls*) := <variants-r(|prog)> t;
        <debug(!"Variants: ")> funcalls*;
        <not(foldable)> t;
        update-trace(|t)

    drive(r|prog): t@FCall(_, _) -> Fold(folded-to, renamings)
    where
        (folded-to, renamings) := <foldable> t;
        <debug(!"Foldable: ")> (t, folded-to)

    foldable: t -> (t', renamings)
    where
        // using direct or reverse order of serching foldable nodes gives different configuration trees
        t' := <reverse; getfirst(eq-mod-renaming(|t))> <trace>;
        renamings := <zip> (<collect-all(?Var(<id>))> t', <collect-all(?Var(_))> t)

    ana-tree(unspool) =
        switch unspool
            case ?Stop(t): !Leaf(t)
            case ?Fold(t, renamings): !Leaf(Fold(t, renamings))
            case ?Decompose((t, y)): !Node(t, Decompose(<map(ana-tree(unspool))> y))
            case ?Variants(pats*, (t, y)): !Node(t, Variants(pats*, <map(ana-tree(unspool))> y))
            case ?Transient((t, y)): !Node(t, Transient(<ana-tree(unspool)> y))
        end

    variants-r(|prog) = variants(|prog) <+ (?FCall(name, [a|args*]); <variants-r(|prog)> a; inject(|name, args*))

    inject(|name, args*) = (id, map(!FCall(name, [<id>|args*])))

    variants(|prog): fcall@FCall(f-name, [Var(_)|_]) -> (pats*, fcalls*)
    where
        g-defs* := <collect-all(?GDef(f-name, _,_,_) <+ ?GDef(f-name, _,_)); ?[_|_]> prog;
        res := <map(variants-step(|fcall))> g-defs*;
        pats* := <map(?(<id>, _))> res;
        fcalls* := <map(?(_, <id>))> res

    variants-step(|f-call): GDef(name, pat, body) -> <variants-step(|f-call)> GDef(name, pat, [], body)
    variants-step(|f-call): GDef(name, pat, args*, body) -> (new-pat, res)
    where
        <?FCall(f-name, [Var(var-name)|vars*])> f-call;
        new-pat := <pat-with-new-vars> pat;
        <debug(!"Variant step: ")> (var-name, <pat2ctor> new-pat);
        res := <subst-once(|Var(var-name), <pat2ctor> new-pat)> f-call

    subst-once(|t, t'): FCall(name, args*) -> FCall(name, subst-args*)
    where
        <debug> (t, t', args*);
        subst-args*  := <oncetd(?t; !t')> args*

    pat-with-new-vars: Pat(n, a*) -> Pat(n, new-vars*)
    with
        new-vars* := <topdown(try(\DVar(_) -> DVar(<gen-name(|"v")>)\))> a*

    pat2ctor: Pat(name, args*) -> Ctor(name, <topdown(try(\DVar(x) -> Var(x)\))> args*)

    eq-mod-renaming(|t1): t2 -> t2
    where
    	<equal> (<erase-names> t1, <erase-names> t2)

    erase-names = topdown(try(?Var(_); !Var("_")))

    // using dynamic rules to trace all nodes to fold tree later
    init-trace: _ -> None()
    with
        rules ( trace := [] )

    update-trace(|t): _ -> None()
    with
        rules ( trace := [t|<trace>] )

    // simplification rules used to deforest program
    simplify = bottomup(try(\ Node(t, Transient(n)) -> n \))
    remove-transient: Node(t, Transient(n)) -> n
    where
        <not(is-base(|t))> n
    is-base(|t): t -> <collect-one(?Fold(t, _))> t
    where
        <debug(!"Is base: ")> t
